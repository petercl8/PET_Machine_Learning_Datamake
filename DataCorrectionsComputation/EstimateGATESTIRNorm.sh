#!/usr/bin/env bash
## AUTHOR: Robert Twyman
## AUTHOR: Kris Thielemans
## Copyright (C) 2020-2021 University College London
## Licensed under the Apache License, Version 2.0

# This script requires a sinogram of a simulated activity cylinder with no attenuation the size of the FOV unlisted without scatter or randoms generated from the main script.
# It also requires the activity ground truth.
# This script estimates the normalization factors through a ML approach, by comparing the reconstructed sinogram to the ground truth.
# It requires the same scanner geometry and forward projector as used in the actual image reconstruction.
# The sinogram should be span-1 even if the actual scanner is not. For a non-span-1 scanner, the normfactors can be fitted to a template of the STIR scanner header with the proper span.
# If the output is inf or NAN, try running the simulation for longer. The sinogram is probably too low count and the estimation is giving zeros.

FOVCylindricalActivityVolumeFilename=activity.hv # Activity pre-GATE. We also need the binary file in the same folder.
MeasuredData=../VoxelisedSimulation/Output/Unlisted/Coincidences/Sino_Sim_mMRNormAll.hs # Sinogram from unlisting the GATE simulation without random and scatter.  

#OutputFilename=ray_tracing_D690 # Created by this script.
OutputFilename=parallelproj_mMR

## Parameter file to use for STIR forward projection. We've successfully used parallelproj (paralleproj.par) and Matrix.
#forward_project_pars=projector-matrix_ray_tracing.par
forward_project_pars=projector-parallelproj.par

norm_template=0 # Put a normalization template here if you want non-span-1 normfactors.

## ML Normfactors loop numbers (Hardcoded for now)
outer_iters=5 # default = 5
eff_iters=6	# default = 6

## factors are the norm_filename_prefix generated by find_ML_normfactors3D and input for apply_normfactors3D
norm_factors="norm_factors"
eff_factors="eff_factors"

## Create the STIR (model) forward projection of the object.
model_data=STIR_forward_projections # This is just a filename


## Forward project using SITR to get model data
# Output is currently always in STIR-Interfile format.
echo "Forward projecting (${FOVCylindricalActivityVolumeFilename}) with STIR to get model_data"
forward_project ${model_data} ${FOVCylindricalActivityVolumeFilename} ${MeasuredData} ${forward_project_pars} > /dev/null 2>&1 # Creates: STIR_forward.hs, STIR_forward.s
echo "stir_math is creating sinogram of ones."

stir_math -s --including-first --times-scalar 0 --add-scalar 1 sino_ones.hs ${model_data}".hs" # Creates: ones.hs, ones.s
#list_projdata_info --all sino_ones.hs


## find ML normfactors
# Find normalisation factors using an ML approach. Just a wrapper around ML_estimate_component_based_normalisation
# These normfactors are in data space (see below). There are three types: geo (geometrical?), eff (efficiency?), and block (detector block?).
# Code Creates: norm_factors_eff_1_1.out --> norm_factors_eff_{outer_iters}_{eff_iters}, 
#               norm_factors_block_1     --> norm_factors_block_{outer_iters}, and norm_factors_geo_1 --> norm_factors_geo_{outer_iters}
echo "Running STIR's find_ML_normfactors3D"
find_ML_normfactors3D ${norm_factors} ${MeasuredData} ${model_data}".hs" ${outer_iters} ${eff_iters} 


## mutiply ones with the norm factors to get a sino
# Apply normalisation factors estimated using the ML code to projection data. 
echo "Running STIR's apply_normfactors3D"
## This executable can error with `ERROR: Cannot do geometric factors in 3D yet`. This is likely due to being on the `release_4` branch of STIR
apply_normfactors3D ${eff_factors}"_span1" ${norm_factors} sino_ones.hs 1 ${outer_iters} ${eff_iters}	# Creates: eff_factors_span1.hs, eff_factors_span1.s


## Creates the span-1 normalisation sinogram (by taking the reciprocal)
echo "Inverting the eff_factors (span-1) to get a normalisation sinogram (span-1)"

stir_math -s --including-first --power -1 ${OutputFilename}"_span1" ${eff_factors}"_span1.hs" # Creates: {OutputFilename}.hs, {OutputFilename}.s


## Creates the span-n normalisation sinogram if $span > 1
# eff_factors are inverse normalisation sinogram.
if [ ${norm_template} != 0 ]; then
	echo "SSRB the eff_factors_span1 to match the dimensions of '${norm_template}'"
	SSRB --template ${norm_template} ${eff_factors} ${eff_factors}"_span1.hs" 0 # eff_factors is out (rebinned data)
	stir_math -s --including-first --power -1 ${OutputFilename} ${eff_factors}".hs" # inverts sinogram and saves as OutputFilename
	echo "Compressed Normalisation sinogram is saved as: ${OutputFilename}"
else
	## No template given, rename the ${OutputFilename}"_span1.hs" to ${OutputFilename}
	stir_math -s ${OutputFilename} ${OutputFilename}"_span1.hs"
	echo "Normalisation sinogram is saved as: ${OutputFilename}"
fi



cleanup=1
if [ ${cleanup} = 1 ]; then
	echo "Cleaning up!"
	rm ${norm_factors}*
	for suffix in ".hs" ".s"; do
		rm "sino_ones"${suffix}
		rm ${eff_factors}"_span1"${suffix}
		rm ${model_data}${suffix}
		if [ ${norm_template} = 0 ]; then
			echo "No norm_template so ${OutputFilename}_span1 and ${OutputFilename} are equal"
			rm ${OutputFilename}"_span1"${suffix}
		fi
	done
fi

exit 0